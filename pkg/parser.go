package maqui

import "fmt"

// AST is an Abstract Syntax Tree that contains the statements found inside a file, and its respective symbol table.
// The statements are presented as annotated expressions, that contain the resolved type of the expression, if any.
type AST struct {
	// Global contains the global symbol table for the file
	Global *SymbolTable
	// Statements contains annotated statements with their resolved type if any
	Statements []*AnnotatedExpr
	// Errors list all compile errors
	Errors []CompileError
	// Filename is a string that points to the file that created this AST
	Filename string
}

// Expr defines an expression, that must at a minimum contain the location of the source code that generated it.
type Expr interface {
	// GetLocation returns the location of the source code that generated it
	GetLocation() *Location
}

// AnnotatedExpr contains an expression that has an associated symbol table to it describing the context.
type AnnotatedExpr struct {
	// Stab is a symbol table describing the context of this statement
	Stab *SymbolTable
	// Expr holds an expression
	Expr Expr
}

// GetLocation returns the location of the source code that generated the underlying expression
func (a AnnotatedExpr) GetLocation() *Location {
	return a.Expr.GetLocation()
}

// BadExpr marks an error generated by an incorrect expression. It contains an error description and a location
// pointing to the source code that caused the error.
type BadExpr struct {
	// Location points to where the error was generated
	Location *Location
	// Error gives a description of the error
	Error string
}

// GetLocation returns the location of the source code that generated the error
func (e *BadExpr) GetLocation() *Location {
	return e.Location
}

// FuncDecl is an expression that represents a function declaration. It contains the function name, body and location
// inside the source code.
type FuncDecl struct {
	// Locations points to the source code that created this definition
	Location *Location
	// Name is the name of the function
	Name string
	// Body contains all the statements inside the definition blocks
	Body []Expr
}

// GetLocation returns the location of the source code that generated the function
func (e FuncDecl) GetLocation() *Location {
	return e.Location
}

// VariableDecl is an expression that defines a variable declaration. It contains the name, value (also an expression),
// and resolved type of the variable. It also has a [Location] that points to where the variable was created in the
// source code.
type VariableDecl struct {
	// Location points to the source code that created the expression
	Location *Location
	// Name of the created variable
	Name string
	// Value is what the variable is assigned to
	Value Expr
	// ResolvedType contains the type the compiler resolved this variable to
	ResolvedType Type
}

// GetLocation returns the location of the source code that generated the expression
func (e VariableDecl) GetLocation() *Location {
	return e.Location
}

// FuncCall is an expression that defines a function call inside the code. It contains the name of the call function,
// the arguments provided and the type resolved for each argument, and the location inside the source that created
// this call.
type FuncCall struct {
	// Location points to the source code that created the expression
	Location *Location
	// Name is the name of the called function
	Name string
	// Args is an expression list of the provided arguments
	Args []Expr
	// ResolvedTypes contains the resolved types of the arguments. It has the same length and position in relation to
	// Args. That means position 0 corresponds to the first argument, 1 to the second and so on.
	ResolvedTypes []Type
}

// GetLocation returns the location of the source code that generated the expression
func (e FuncCall) GetLocation() *Location {
	return e.Location
}

// Identifier is an expression the holds an identifier. It contains its location inside the code and the identifier name.
type Identifier struct {
	// Location points to the source code that created the expression
	Location *Location
	// Name of the identifier
	Name string
}

// GetLocation returns the location of the source code that generated the expression
func (i Identifier) GetLocation() *Location {
	return i.Location
}

// EOS or End-of-Stream is a special expression that signals parsing should stop. It has no semantic meaning and should
// be omitted from the [AST].
type EOS struct {
	// Location will always point to the end of the file
	Location *Location
}

// GetLocation will return the end of the file position
func (e EOS) GetLocation() *Location {
	return e.Location
}

// BinaryOp defines a binary operation type. Valid types are addition (+), subtraction (-), multiplication (*), and
// division (/).
type BinaryOp string

const (
	// BinaryAddition is the sum (+) between two expressions
	BinaryAddition BinaryOp = "+"
	// BinarySubtraction is the subtraction (-) between two expressions
	BinarySubtraction BinaryOp = "-"
	// BinaryMultiplication is the multiplication (*) of two expressions
	BinaryMultiplication BinaryOp = "*"
	// BinaryDivision is the division (/) of two expressions
	BinaryDivision BinaryOp = "/"
)

// BinaryExpr is an expression that defines an operation between two expressions. The operator is a [BinaryOp], that
// holds what operation is taking place. It contains the location pointing to where the expression is inside the source,
// and the operands (also expressions).
type BinaryExpr struct {
	// Location points to the source code that created the expression
	Location *Location
	// Operation is the binary operation being performed
	Operation BinaryOp
	// Op1 is the first operand
	Op1 Expr
	// Op2 is the second operand
	Op2 Expr
}

// GetLocation returns the location of the source code that generated the expression
func (e BinaryExpr) GetLocation() *Location {
	return e.Location
}

// UnaryOp a unary operation is done with only one receiving operand. For example -1 is the unary negation over the
// operand 1.
type UnaryOp string

const (
	// UnaryNegative is the negation of an expression. For example -1.
	UnaryNegative UnaryOp = "-"
)

// UnaryExpr is an operation over only one operand. It contains the receiver, the operation performed, and the source
// code location that generated this expression.
type UnaryExpr struct {
	// Location points to the source code that created the expression
	Location *Location
	// Operation is the unary operation being performed
	Operation UnaryOp
	// Operand is the receiving operation
	Operand Expr
}

// GetLocation returns the location of the source code that generated the expression
func (e UnaryExpr) GetLocation() *Location {
	return e.Location
}

// LiteralType defines the type of an immediate expression
type LiteralType int

const (
	// LiteralNumber defines the immediate value type of a number. Also called untyped number
	LiteralNumber LiteralType = iota
	// LiteralString defines the immediate value type of an escaped text
	LiteralString
)

// LiteralExpr contains an expression that's used as an immediate. It contains  the type (LiteralType), location and
// value of the expression.
type LiteralExpr struct {
	// Location points to the source code that created the expression
	Location *Location
	// Typ is the type of the literal
	Typ LiteralType
	// Value holds the value of the literal. For string literals the commas escaping the string will be removed.
	Value string
}

// GetLocation returns the location of the source code that generated the expression
func (e LiteralExpr) GetLocation() *Location {
	return e.Location
}

// IfExpr holds a logic branching expression.
type IfExpr struct {
	// Location points to the source code that created the expression
	Location *Location
	// Condition is the evaluation that decides if the consequent should be executed
	Condition Expr
	// Consequent is the expressions that should run if the condition is truthful
	Consequent []Expr
	// Else is an optional slice of expressions that run if the condition is false
	Else []Expr
}

// GetLocation returns the location of the source code that generated the expression
func (e IfExpr) GetLocation() *Location {
	return e.Location
}

// isValidExpr will return false if the expression is of type *BadExpr or *EOS
func isValidExpr(expr Expr) bool {
	if expr == nil {
		return false
	}

	switch expr.(type) {
	case *BadExpr:
		return false
	case *EOS:
		return false
	}

	return true
}

// SyntacticAnalyzer defines the expected behavior of a code parser. The syntactic analyzer should be able to
// evaluate the logic and construction of the source code, and is location-aware. Its main responsibility is to
// organize the code into an ordered AST.
type SyntacticAnalyzer interface {
	// Do runs the syntactic analyzer asynchronously and starts putting the resulting expressions in the buffer
	Do()
	// Get gets one expression from the output buffer
	Get() Expr
	// GetFilename returns the file used to create this syntactic analyzer
	GetFilename() string
}

// Parser is the default syntactic analyzer for Maqui. It uses recursive decent to generate an AST.
type Parser struct {
	// filename is the name of the file used to create this parser
	filename string
	// tokenizer is the provider of the tokens used in parsing
	tokenizer Tokenizer
	// output is the buffer where the processed expressions are stored
	output chan Expr
	// buf holds the next token coming from the tokenizer. It might be empty and populated only when needed. It's used
	// to keep peeked tokens without having to roll back the stream.
	buf *Token
}

// NewParser creates a Parses with the provided tokenizer as the token provider. It sets the filename of Parser to the
// filename of the tokenizer.
func NewParser(tokenizer Tokenizer) *Parser {
	return &Parser{
		tokenizer: tokenizer,
		filename:  tokenizer.GetFilename(),
		output:    make(chan Expr, 2),
	}
}

// Get fetches one expression from the output buffer. Will blocks if no token is available. After receiving an [EOS]
// expression no more expressions should be fetched.
func (p *Parser) Get() Expr {
	return <-p.Chan()
}

// Chan returns the underlying output channel
func (p *Parser) Chan() chan Expr {
	return p.output
}

// GetFilename returns the name of the filename that created this parser.
func (p *Parser) GetFilename() string {
	return p.filename
}

// Do runs the parser asynchronously and starts putting the resulting expressions in the buffer. It will also start the
// token provider.
func (p *Parser) Do() {
	go p.tokenizer.Do()

	for p.peek().Typ != TokenEOF {
		p.output <- p.statement()
	}

	p.output <- &EOS{p.next().Loc}
	close(p.output)
}

// Run runs the parser synchronously and returns the generated AST. The asynchronous Do should be preferred.
func (p *Parser) Run() *AST {
	go p.tokenizer.Do()

	ast := &AST{
		Filename: p.GetFilename(),
	}

	for p.peek().Typ != TokenEOF {
		ast.Statements = append(ast.Statements, &AnnotatedExpr{
			Expr: p.statement(),
		})
	}

	return ast
}

// peek fetches a coppy of the next token without consuming it. Internally it uses the buffer (buf) of the Parser. If
// the buffer already has a token it will be returned. If the buffer is empty the next token is fetched and stored in
// the buffer.
func (p *Parser) peek() Token {
	if p.buf == nil {
		temp := p.next()
		p.buf = &temp
	}

	return *p.buf
}

// next gets the next token in the stream and moves the position by one. Internally it will first check the buffer (buf)
// if it contains a token that token will be returned and the buffer will be emptied. If the buffer is empty a new
// token is fetched from the tokenizer.
func (p *Parser) next() Token {
	if p.buf != nil {
		if p.buf.Typ == TokenEOF {
			// If the token is EOF don't clear the buffer
			return *p.buf
		}

		temp := p.buf
		p.buf = nil

		return *temp
	}

	tok := p.tokenizer.Get()
	if !tok.isValid() {
		// If a token is invalid (such as Error or EOF) keep it buffered since no more valid tokens are expected
		p.buf = &tok
	}

	if tok.isComment() {
		// Skip comments
		return p.next()
	}

	return tok
}

// expect fetches the next token and moves the position. If the provided type matches the fetched token, then it's
// return. If the token's type does not match nil is returned.
func (p *Parser) expect(typ TokenType) *Token {
	tok := p.next()
	if tok.Typ != typ {
		return nil
	}

	return &tok
}

// check peeks the next token without moving the position and returns true if the type matches the provided argument.
func (p *Parser) check(typ TokenType) bool {
	return p.peek().Typ == typ
}

// consume fetches the next token moving the position and returns true if the type matches the provided argument.
func (p *Parser) consume(typ TokenType) bool {
	tok := p.next()
	if tok.Typ != typ {
		return false
	}

	return true
}

// errorf is a shorthand for creating a *BadExpr with formatted text
func (p *Parser) errorf(l *Location, format string, args ...interface{}) Expr {
	return &BadExpr{
		Location: l,
		Error:    fmt.Sprintf(format, args...),
	}
}

// statement is the entry point for parsing. It will first try to resolve the token type to find out what parsing branch
// to take. If not able, it will use recursive decent to build the tree for the expression.
func (p *Parser) statement() Expr {
	switch tok := p.peek(); tok.Typ {
	case TokenFunc:
		return p.funcDecl()
	case TokenIf:
		return p.ifBranch()
	default:
		return p.expr()
	}
}

// funcDecl builds a function declaration (*FuncDecl) expression. If it fails a *BadExpr will be returned.
func (p *Parser) funcDecl() Expr {
	start := p.next().Loc // func keyword

	name := p.expect(TokenIdentifier)
	if name == nil {
		return p.errorf(start, "expected function name")
	}

	// TODO: Allow arguments
	if !p.consume(TokenOpenParentheses) || !p.consume(TokenCloseParentheses) {
		return p.errorf(start, "bad function declaration")
	}

	return &FuncDecl{
		Location: start,
		Name:     name.Value,
		Body:     p.blockStmt(),
	}
}

// ifBranch builds an *IfExpr from the stream. If it fails a *BadExpr will be returned.
func (p *Parser) ifBranch() Expr {
	ifKw := p.expect(TokenIf)
	if ifKw == nil {
		return p.errorf(nil, "expected an if statement")
	}

	expr := &IfExpr{
		Location:  ifKw.Loc,
		Condition: p.expr(),
	}

	if !p.check(TokenOpenCurly) {
		return p.errorf(expr.Location, "expected a code blocks after if statement")
	}

	expr.Consequent = p.blockStmt()

	if !p.check(TokenElse) {
		return expr
	}

	p.next() // Skip else
	expr.Else = p.blockStmt()
	return expr
}

// blockStmt parses a list of statements. If it fails a *BadExpr will be placed inside the returned slice, but it might
// have valid Expr inside.
func (p *Parser) blockStmt() []Expr {
	if tok := p.expect(TokenOpenCurly); tok == nil {
		return []Expr{p.errorf(nil, "invalid blocks statement")}
	}

	var exprs []Expr
	for tok := p.peek(); tok.isValid() && tok.Typ != TokenCloseCurly; tok = p.peek() {
		exprs = append(exprs, p.statement())
	}

	switch closer := p.next(); closer.Typ {
	case TokenCloseCurly:
		return exprs
	case TokenError:
		return append(exprs, p.errorf(closer.Loc, "invalid blocks statement"))
	case TokenEOF:
		return append(exprs, p.errorf(closer.Loc, "unclosed blocks statement"))
	default:
		return append(exprs, p.errorf(closer.Loc, "unexpected token in blocks statement"))
	}
}

// expr parses an expression using recursive decent. The expression might be a *BadExpr if a invalid token is found.
func (p *Parser) expr() Expr {
	expr := p.additiveExpr()

	id, ok := expr.(*Identifier)
	if ok {
		tok := p.peek()
		if tok.Typ == TokenDeclaration {
			return p.varDeclExpr(id)
		}

		if tok.Typ == TokenOpenParentheses {
			return p.funcCall(id)
		}
	}

	return expr
}

// varDeclExpr builds a variable declaration (*VariableDecl) expression from the Identifier if possible. If the stream
// doesn't contain a declaration then an Identifier expression is returned.
func (p *Parser) varDeclExpr(id *Identifier) Expr {
	if p.peek().Typ != TokenDeclaration {
		return id
	}

	p.next() // Skip :=

	return &VariableDecl{
		Name:  id.Name,
		Value: p.expr(),
	}
}

// funcCall will try to parse a function call (*FuncCall). If an invalid token is found a *BadExpr will be returned
// containing an error description.
func (p *Parser) funcCall(id *Identifier) Expr {
	if !p.consume(TokenOpenParentheses) {
		return p.errorf(nil, "bad function call")
	}

	var args []Expr
	for tok := p.peek(); tok.isValid() && tok.Typ != TokenCloseParentheses; tok = p.peek() {
		args = append(args, p.expr())

		if !p.check(TokenComma) {
			break
		}

		p.next() // Skip the comma
	}

	if !p.consume(TokenCloseParentheses) {
		return p.errorf(nil, "bad function call")
	}

	return &FuncCall{
		Name: id.Name,
		Args: args,
	}
}

// additiveExpr will parse an additive expression if found, or decent otherwise
func (p *Parser) additiveExpr() Expr {
	lhs := p.multiplicativeExpr()

	for true {
		if tok := p.peek(); tok.Typ == TokenPlus || tok.Typ == TokenMinus {
			// Chained operands (for example 1 * 3 + 1). Go over the operand and nest
			p.next()

			rhs := p.additiveExpr()
			lhs = &BinaryExpr{
				Location:  tok.Loc,
				Operation: BinaryOp(tok.Value),
				Op1:       lhs,
				Op2:       rhs,
			}

			continue
		}

		return lhs
	}

	return lhs // Unreachable
}

// multiplicativeExpr will parse a multiplicative expression if found, or decent otherwise
func (p *Parser) multiplicativeExpr() Expr {
	lhs := p.unaryExpr()

	for true {
		if tok := p.peek(); tok.Typ == TokenMulti || tok.Typ == TokenDiv {
			// Chained operands (for example 1 / 3 * 1). Go over the operand and nest
			p.next()

			rhs := p.multiplicativeExpr()
			lhs = &BinaryExpr{
				Location:  lhs.GetLocation(),
				Operation: BinaryOp(tok.Value),
				Op1:       lhs,
				Op2:       rhs,
			}

			continue
		}

		return lhs
	}

	return lhs // Unreachable
}

// unaryExpr will parse a unary expression if found, or decent otherwise
func (p *Parser) unaryExpr() Expr {
	if p.check(TokenMinus) { // Unary negative
		tok := p.next()

		return &UnaryExpr{
			Location:  tok.Loc,
			Operation: UnaryNegative,
			Operand:   p.primary(),
		}
	}

	return p.primary()
}

// primary will parse a primary expression if found, or decent otherwise. Primary expressions are identifiers, literals,
// or parenthesised expressions.
func (p *Parser) primary() Expr {
	switch tok := p.peek(); tok.Typ {
	case TokenOpenParentheses:
		return p.parenthesisedExpression()
	case TokenIdentifier:
		return p.identifier()
	}

	return p.literal()
}

// parenthesisedExpression unwraps a parenthesised expression and returns the contained expression. If the expression
// is not correctly parenthesised, a *BadExpr will be returned.
func (p *Parser) parenthesisedExpression() Expr {
	if tok := p.next(); tok.Typ != TokenOpenParentheses {
		return p.errorf(tok.Loc, "expected opening parenthesis")
	}

	exp := p.expr()

	if tok := p.next(); tok.Typ != TokenCloseParentheses {
		return p.errorf(tok.Loc, "expected closing parenthesis")
	}

	return exp
}

// identifier returns an identifier expression (*Identifier). If the next expression is not an identifier a *BadExpr is
// returned.
func (p *Parser) identifier() Expr {
	tok := p.next()
	if tok.Typ != TokenIdentifier {
		return p.errorf(tok.Loc, "expected an identifier")
	}

	return &Identifier{
		Location: tok.Loc,
		Name:     tok.Value,
	}
}

// literal parses a literal, either a string or numeric literal and returns a *LiteralExpr. If no literal is found a
// *BadExpr is returned.
func (p *Parser) literal() Expr {
	switch tok := p.peek(); tok.Typ {
	case TokenNumber:
		return &LiteralExpr{
			Location: tok.Loc,
			Typ:      LiteralNumber,
			Value:    p.next().Value,
		}
	case TokenString:
		return &LiteralExpr{
			Location: tok.Loc,
			Typ:      LiteralString,
			Value:    p.next().Value,
		}
	default:
		p.next() // Skip errored token
		return p.errorf(tok.Loc, "invalid symbol '%s'", tok.Value)
	}
}
